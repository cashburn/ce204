import java.util.HashMap;
public class ExpTree {
    public static final int numNode = 0, idNode = 1, opNode = 2, letNode = 3, andNode = 4, defNode = 5;
    public static final int exp = 0, times = 1, div = 2, mod = 3, plus = 4, minus = 5;
    public static final int[] order = {0,1,1,1,2,2}; //order[exp] = o, order[mod] = 1, etc.

    public int type;
    public int value;
    public ExpTree left, right;

    public ExpTree (int typ, int val, ExpTree l, ExpTree r) {
        if (typ == numNode) {
            if (val < 0) {
                throw new TreeException("ERROR: negative integer");
            }
            if (l != null || r != null) {
                throw new TreeException("ERROR: number cannot have children");
            }
        }
        if (typ == idNode) {
            if (val < 'A' || val > 'Z') {
                throw new TreeException("ERROR: incorrect identifier");
            }
            if (l != null || r != null) {
                throw new TreeException("ERROR: identifier cannot have children");
            }
        }
        if (typ == opNode) {
            if (val != '+' && val != '-' && val != '*' && val != '/' &&
                    val != '%' && val != '^') {
                throw new TreeException("ERROR: incorrect operator");
            }
            if (l == null || r == null)
                throw new TreeException("ERROR: operator must have children");
        }
        type = typ;
        value = val;
        left = l;
        right = r;
    }

    public String postString() {
        String s = "";
        if (type == letNode) {
            return right.postString();
        }
        else if (left != null && right != null) {
            s += left.postString() + " ";
            s += right.postString() + " ";
        }
        if (type == numNode) {
            s += value;
        }
        else {
            s += (char) value;
        }
        return s;
    }

    public String toString() {
        String s = "";
        if (type == letNode) {
            s += "let ";
            s += left.toString();
            s += "in ";
            s += right.toString();
        }
        else if (type == andNode) {
            s += left.toString();
            s += "and ";
            s += right.toString();
        }
        else if (type == defNode) {
            s += (char) value + " = ";
            s += left.toString() + " ";
        }
        else {
            if (left != null) {
                int precedence = 0;
                if (left.type == opNode) {
                    if ((precedence = precedence(left.value, value)) > 0) {
                        s += "(";
                    }
                }
                s += left.toString();
                if (precedence > 0) {
                    s += ")";
                }
            }
            if (type == numNode) {
                s += value;
            }
            else {
                s += (char) value;
            }
            if (right != null) {
                int precedence = 0;
                if (right.type == opNode) {
                    if ((precedence = precedence(right.value, value)) > 0) {
                        s += "(";
                    }
                }
                s += right.toString();
                if (precedence > 0) {
                    s += ")";
                }
            }
        }
        return s;
    }

    private static int precedence(int a, int b) {
        int aOrder = 0;
        int bOrder = 0;
        switch ((char) a) {
            case '^':
                aOrder = order[exp];
                break;
            case '*':
                aOrder = order[times];
                break;
            case '/':
                aOrder = order[div];
                break;
            case '%':
                aOrder = order[mod];
                break;
            case '+':
                aOrder = order[plus];
                break;
            case '-':
                aOrder = order[minus];
                break;
        }
        switch ((char) b) {
            case '^':
                bOrder = order[exp];
                break;
            case '*':
                bOrder = order[times];
                break;
            case '/':
                bOrder = order[div];
                break;
            case '%':
                bOrder = order[mod];
                break;
            case '+':
                bOrder = order[plus];
                break;
            case '-':
                bOrder = order[minus];
                break;
        }
        return aOrder - bOrder;
    }

    public int evaluate(HashMap<Character, Integer> m) {
        if (m != null) {
            if (type == idNode) {
                return m.get((char)value);
            }
        }
        if (type == numNode) {
            return value;
        }
        else if (type == idNode) {
            return value - 'A';
        }
        if (type == defNode) {
            return left.evaluate(m);
        }
        else if (type == opNode) {
            switch (value) {
                case '+':
                    return left.evaluate(m) + right.evaluate(m);

                case '-':
                    return left.evaluate(m) - right.evaluate(m);

                case '*':
                    return left.evaluate(m) * right.evaluate(m);

                case '/':
                    return left.evaluate(m) / right.evaluate(m);

                case '%':
                    return left.evaluate(m) % right.evaluate(m);

                case '^':
                    return (int) Math.pow((double) left.evaluate(m), (double) right.evaluate(m));
            }
        }
        return value;
    }
}

class TreeException extends RuntimeException {
    public TreeException(String s) {
        super(s);
    }
}
